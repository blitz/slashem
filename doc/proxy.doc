Introduction

This file documents the proxy windowing interface. It is far from complete.

Contents:
	I.    Adding a standard procedure
	II.   Adding a standard callback

I.  Adding a standard procedure

First choose a name for the new procedure. We will use ${name} to refer to
the lowercase version of the chosen name in this document and ${NAME} to
refer to the uppercase version.

Modify the source as follows:

A.  win/proxy/ext_protocol.html

 o Add a new procedure ID to the list using the next unused ID number.
 o Add a new section describing the procedure, its parameters and result.
 o Note the formal description of parameters and results must follow
   the syntax of Sun's XDR language so that the test procedure laid
   out in win/proxy/Makefile.* will be valid. Formal descriptions must
   be enclosed in a <pre>...</pre> pair. These html tags must be on a
   line by themselves.
 o If you have access to rpcgen then you can use the relevant makefile
   to build rpcgen-nhext_xdr.c and so check your syntax.

B.  include/winproxy.h

 o Add a new procedure ID to the list using the ID chosen above:
	#define EXT_FID_${NAME}		0x##
 o Add a new field to the end of struct window_ext_procs to hold a pointer
   to a function which takes the relevant parameters and returns the
   relevant result. The field should be named winext_${name}.
 o If any of the parameters or return value are too complex for nhext_rpc()
   then define a struct proxy_${name}_req and/or proxy_${name}_res
   and declare an XDR function to handle it (enclose the declaration
   inside an #ifdef NHXDR_H ... #endif pair).

C.  win/proxy/compxdr.c

If you declared an XDR function in winproxy.h, then you need to define
it in this file. Many XDR functions consist simply of calling standard
XDR functions for each field of the aggregate type and returning the
bitwise AND of their return values. XDR functions should not return
early if an error occurs so the use of logical AND operators is
generally to be avoided.

D.  win/proxy/winproxy.c

Define the proxy_${name} function you declared above. This function will
be called by the game when it wants to perform the relevant procedure.
It should:

 o Do any preparation needed on the parameters (normally none).
 o Initialize any buffers that will be used to receive values back from
   the windowing interface. The XDR convention is that NULL pointers
   indicate that XDR should allocate memory whereas non-NULL pointers
   indicate that XDR should use the pre-allocated memory.
 o Call nhext_rpc() to send an RPC packet to the windowing interface and
   read back the reply.
 o Return the result (if any).

E.  win/proxy/proxysvc.c

This module implements the support in the windowing interface(s) for the
procedure. You should:

 o Declare a static function to handle the incoming request as follows:
	static void FDECL(proxy_svc_${name}, \
				(unsigned short, NhExtXdr *, NhExtXdr *));
 o Define the handling function. It should:
   - Decode the incoming parameters by calling nhext_rpc_params() and
     passing it the request XDR handle and parameters which describe the
     format of the parameters to your procedure.
   - Take whatever action the game is requesting.
   - Encode the result of that action ready to be sent back to the game
     by calling nhext_rpc_params() and passing it the reply XDR handler
     and parameters which describe the format of the results of your
     procedure.
 o Add an entry to the services array as follows:
	EXT_FID_${NAME},		proxy_svc_${name},

F.  external window interface(s)

Add an entry to the window_ext_procs structure for each external window
interface for the newly defined winext_${name} field. This should either
be a hook function that does nothing except return an appropriate result
(for window interfaces that do not wish to support the new procedure) or
a function to do the work for the new procedure as newly documented in
ext_protocol.html.

G.  game source

Add code to call proxy_${name} at the appropriate points in the game source.

II.  Adding a standard callback

First choose a name for the new callback. We will use ${name} to refer to
the lowercase version of the chosen name in this document and ${NAME} to
refer to the uppercase version.

Modify the source as follows:

A.  win/proxy/ext_protocol.html

 o Add a new callback ID to the list using the next unused ID number.
 o Add a new section describing the callback, its parameters and result.
 o Note the formal description of parameters and results must follow
   the syntax of Sun's XDR language so that the test procedure laid
   out in win/proxy/Makefile.* will be valid. Formal descriptions must
   be enclosed in a <pre>...</pre> pair. These html tags must be on a
   line by themselves.
 o If you have access to rpcgen then you can use the relevant makefile
   to build rpcgen-nhext_xdr.c and so check your syntax.

B.  include/proxycb.h

 o Add a new callback ID to the list using the ID chosen above:
	#define EXT_CID_${NAME}		0x##
 o Declare proxy_cb_${name} as a function which takes the relevant
   parameters and returns the relevant result.
 o If any of the parameters or return value are too complex for nhext_rpc()
   then define a struct proxycb_${name}_req and/or proxycb_${name}_res
   and declare an XDR function to handle it (enclose the declaration
   inside an #ifdef NHXDR_H ... #endif pair).

C.  win/proxy/compxdr.c

If you declared an XDR function in proxycb.h, then you need to define
it in this file. Many XDR functions consist simply of calling standard
XDR functions for each field of the aggregate type and returning the
bitwise AND of their return values. XDR functions should not return
early if an error occurs so the use of logical AND operators is
generally to be avoided.

D.  win/proxy/proxycb.c

Define the proxy_cb_${name} function you declared above. This
function will be called by windowing interfaces when they want
to perform the relevant callback. It should:

 o Do any preparation needed on the parameters (normally none).
 o Initialize any buffers that will be used to receive values back
   from the game. The XDR convention is that NULL pointers indicate
   that XDR should allocate memory whereas non-NULL pointers indicate
   that XDR should use the pre-allocated memory.
 o Call nhext_rpc() to send an RPC packet to the game and read back
   the reply.
 o Return the result (if any).

E.  win/proxy/callback.c

This module implements the support in the game executable for the
call back. You should:

 o Declare a static function to handle the incoming request as follows:
	static void FDECL(callback_${name}, \
				(unsigned short, NhExtXdr *, NhExtXdr *));
 o Define the handling function. It should:
   - Decode the incoming parameters by calling nhext_rpc_params() and
     passing it the request XDR handle and parameters which describe the
     format of the parameters to your call back.
   - Take whatever action the calling windowing interface is requesting.
   - Encode the result of that action ready to be sent back to the
     windowing port by calling nhext_rpc_params() and passing it the
     reply XDR handler and parameters which describe the format of the
     results of your call back.
 o Add an entry to the proxy_callbacks array as follows:
	EXT_CID_${NAME},		callback_${name},

F.  external window interface(s)

Add code to call proxy_cb_${name} to the external window interfaces which
need the new callback.
