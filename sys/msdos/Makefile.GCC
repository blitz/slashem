#	SCCS Id: @(#)Makefile.GCC	      3.4     2002/03/17
#	Copyright (c) NetHack PC Development Team 1996-2002.
#	PC NetHack 3.4 Makefile for djgpp V2
#
#	Gnu gcc compiler for msdos (djgpp)
#	Requires Gnu Make utility (V3.79 or greater) supplied with djgpp V2.03
#	WAC: 	PLEASE NOTE THE CHANGE IN VERSION OF THE MAKE UTILITY
#		OLDER VERSIONS WILL NOT WORK DUE TO PROBLEMS PARSING 
#		FORWARD/BACK SLASHES
#
#	For questions or comments: devteam@nethack.org
#
#	In addition to your C compiler,
#
#  if you want to change   you will need a
#  files with suffix   workalike for
#	  .y	     yacc
#	  .l	     lex
#
#	Note that flex (lex) and bison (yacc) are included with the
#	djgpp distribution and work quite well.	 This makefile assumes
#	you have them installed correctly.

# Game Installation Variables
# NOTE: Make sure GAMEDIR exists before make is started.

GAME = slashem
#GAME = nethack

# The GNU Make has a problem if you include a drive spec below (unfortunately).
#GAMEDIR = \games\slashemd
GAMEDIR =..\binary

#
# Directories, gcc likes unix style directory specs
# JRN: But, with DJGPP, I don't think it needs them.
#   Keeping these there for compatibility with old rules, but they're
#    unneeded
#

DDAT  = ../dat
DUTIL = ../util
DSRC  = ../src
DINCL = ../include

# But we must use dos directory specs to find src files, so....

DAT  = ..\dat
DOC  = ..\doc
INCL = ..\include
MSYS = ..\sys\msdos
SRC  = ..\src
SSHR = ..\sys\share
UTIL = ..\util
WIN  = ..\win\tty
WSHR = ..\win\share

#
#  Executables.

CC    = gcc
#CC    = redir -ea cerrors.out gcc
LINK  = gcc
MAKEBIN  = make

# if you have a uudecode program, add its name here
# otherwise leave blank
UUDECODE = uudecode

#
# Special libraries and how to link them in.
# NOTE lwmemu has a panic.o in its library,  so it can't be used :(

LIBS = -lpc -lemu

# WAC
# if you have an executable compressor (DJP for DJGPP),  place it here
EXECOMPRESS =
#EXECOMPRESS = UPX -9
#EXECOMPRESS = DJP -0

# If TERMLIB is defined in pcconf.h, comment out the upper line and
# uncomment the lower.	Note that you must build the termc library
# and place it in djgpp's lib directory.  See termcap.zip for details

TERMLIB =
#TERMLIB = -ltermc

#
#  Yacc/Lex ... if you got 'em.
#
# If you have yacc/lex or a work-alike set YACC_LEX to Y
#
YACC_LEX = N

# If YACC_LEX is Y above, set the following to values appropriate for
# your tools.
#
YACC   = bison -y -o y_tab.c
LEX    = flex
YTABC  = y_tab.c
YTABH  = y_tab.h
LEXYYC = lexyy.c

#
# Uncomment the line below if you want to store all the level files,
# help files, etc. in a single library file.

USE_DLB = Y

# djgpp ships with an ls.exe command in filutils (or is it shlutils?)
# Anyway, if you have it, change it, if you don't, don't.

LS = dir /l/b/-p # DOS command WAC - disable pause for dos6
#LS = ls -1        # ls.exe from djgpp distribution
#LS = *dir /l/b/z        # 4DOS command - cuts through ALIASes

# slowly adjusting to 'update' for fun
# if you want to try it, uncomment the top and comment the uncommented one
#UPD = update # update.exe from djgpp
#UPD = cp    # cp.exe from filutils
UPD = copy  # copy from DOS


# To build a binary without any graphics
# suitable for blind players,
# set SUPPRESS_GRAPHICS to Y
# (Note: binary will require ANSI.SYS driver or equivalent loaded)
# SUPPRESS_GRAPHICS = Y
SUPPRESS_GRAPHICS = 

# set USE_VGA to Y to use the VGA tiles
# you also need to uncomment SCREEN_VGA in pcconf.h
USE_VGA = Y
#USE_VGA

# set USE_ALLEGRO to Y to use the allegro library
# set USE_AALIB to Y to use anti-aliasing library
# BE SURE TO ALSO UNCOMMENT OUT the #define ALLEG_FX in pcconf.h

#USE_ALLEGRO =
USE_ALLEGRO = Y

USE_AALIB = 
#USE_AALIB = Y

#
# set USE_BIG_BMP to Y to have one big BMP rather than many small ones
#USE_BIG_BMP =
USE_BIG_BMP = Y

#############################################################################
#
# nothing below this line should have to be changed
#

GAMEFILE = $(GAMEDIR)\$(GAME).exe

ifeq ($(USE_ALLEGRO),Y)
ifeq ($(USE_AALIB),Y)
LIBALLEGRO = -lalleg -laastr
AAFLAG = -DALLEGRO_USE_AA
else
LIBALLEGRO = -lalleg
AAFLAG =
endif
ifeq ($(USE_BIG_BMP),Y)
txt2bmp_FLG = -b
else
txt2bmp_FLG = -f
endif
else
LIBALLEGRO =
txt2bmp_FLG =
endif

LIBRARIES = $(LIBS) $(TERMLIB) $(LIBALLEGRO)

ifeq ($(USE_DLB),Y)
DLBFLG = -DDLB
else
DLBFLG =
endif

ifeq ($(SUPPRESS_GRAPHICS),Y)
TERMLIB =

# Debugging flags for suppressed graphics
#CFLAGS = -pg -c -I../include $(DLBFLG) -DSUPPRESS_GRAPHICS
#LFLAGS = -pg

CFLAGS = -c -O -I../include $(DLBFLG) -DSUPPRESS_GRAPHICS
LFLAGS =

else

#
#  Flags.
#
# Debugging
#CFLAGS = -pg -c -I../include $(DLBFLG) -DUSE_TILES

#LFLAGS = -pg
#LFLAGS = -pg -lemu

#    Normal
#CFLAGS = -c -O -I../include $(DLBFLG) -DUSE_TILES 
#LFLAGS =

#   Optimize
#
# PGCC should be able to optimize up to -O6.  Use at your own risk.
#CFLAGS = -c -O6 -I../include $(DLBFLG) -DUSE_TILES 
# GCC (and PGCC) can optimize up to -O2 safely
CFLAGS = -c -O2 -I../include $(DLBFLG) -DUSE_TILES
# JRN: I like to do things differently (Optimize and Debug =)
#CFLAGS = -Wall -W -ggdb -c -O3 -I../include $(DLBFLG) -DUSE_TILES
# -s removes debugging symbols.
LFLAGS = 
#LFLAGS = -s -lemu

endif

#
#  Utility Objects.
#

ifeq ($(USE_ALLEGRO),Y)
ALLEGROOBJ      = vidalleg.o 2xsai.o
else
ALLEGROOBJ      =
endif

ifeq ($(USE_VGA),Y)
VGAOBJ      = vidvga.o 
else
VGAOBJ      =
endif

VIDEOOBJ = $(VGAOBJ) $(ALLEGROOBJ)

MAKEOBJS    = makedefs.o  monst.o	 objects.o

SPLEVOBJS   = lev_yacc.o  lev_$(LEX).o	lev_main.o  alloc.o	\
		monst.o	    objects.o	    panic.o  \
		drawing.o	decl.o	stubvid.o

DGNCOMPOBJS = dgn_yacc.o  dgn_$(LEX).o	dgn_main.o  alloc.o	 \
		panic.o

RECOVOBJS   = recover.o

#  Tile related object files.

ifeq ($(SUPPRESS_GRAPHICS),Y)
TEXTIO       =
TILOBJ       =
PLANAR_TIB   =
OVERVIEW_TIB =
TILEUTIL     = 
TILEFILES    = 
TILEFILES2   = 
IGIFREADERS  =
GIFREADERS   = 
PPMWRITERS   = 
else
TEXTIO      = tiletext.o tiletxt.o drawing.o decl.o monst.o objects.o stubvid.o

ifeq ($(USE_ALLEGRO),Y)
ALLEG_TILOBJ      = $(ALLEGROOBJ)
ALLEG_TILEUTIL    = $(TILOBJ) allegro.tag alltiles.tag
ALLEG_IGIFREADERS  = igifread.o alloc.o panic.o
else
ALLEG_TILOBJ      = 
ALLEG_TILEUTIL    = 
ALLEG_IGIFREADERS  = 
endif

ifeq ($(USE_VGA),Y)
VGA_TILOBJ      = pctiles.o $(VGAOBJ)
VGA_PLANAR_TIB  = $(GAME)1.tib
VGA_OVERVIEW_TIB = $(GAME)o.tib
VGA_TILEUTIL    = $(TILOBJ) tile2bin.exe til2bin2.exe $(PLANAR_TIB) $(OVERVIEW_TIB)
VGA_TILEFILES   = $(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt
VGA_TILEFILES2  = $(WSHR)\monthin.txt $(WSHR)\objthin.txt $(WSHR)\oththin.txt
else
VGA_TILOBJ      =
VGA_PLANAR_TIB  =
VGA_OVERVIEW_TIB =
VGA_TILEUTIL    =
VGA_TILEFILES   =
VGA_TILEFILES2  =
endif

TILOBJ      = tile.o $(ALLEG_TILOBJ) $(VGA_TILOBJ)
PLANAR_TIB  = $(VGA_PLANAR_TIB)
OVERVIEW_TIB = $(VGA_OVERVIEW_TIB)
TILEUTIL    = $(ALLEG_TILEUTIL) $(VGA_TILEUTIL)
TILEFILES   = $(VGA_TILEFILES)
TILEFILES2  = $(VGA_TILEFILES2)
IGIFREADERS  = $(ALLEG_IGIFREADERS)

GIFREADERS  = gifread.o alloc.o panic.o
PPMWRITERS  = ppmwrite.o alloc.o panic.o
endif
  
DLBOBJ = dlb.o

#  Object files for the game itself.

VOBJ01 = allmain.o  alloc.o    apply.o	  artifact.o attrib.o
VOBJ02 = ball.o	    bones.o    borg.o	  botl.o     cmd.o 	dbridge.o
VOBJ03 = decl.o	    detect.o   display.o  do.o	     do_name.o
VOBJ04 = do_wear.o  dog.o      dogmove.o  dokick.o   dothrow.o
VOBJ05 = drawing.o  dungeon.o  eat.o	  end.o	     engrave.o
VOBJ06 = exper.o    explode.o  extralev.o files.o    fountain.o
VOBJ07 = getline.o  hack.o     hacklib.o  invent.o   lock.o
VOBJ08 = mail.o	    main.o     makemon.o  mapglyph.o mcastu.o   mhitm.o
VOBJ09 = mhitu.o    minion.o   mkmap.o	  mklev.o    mkmaze.o
VOBJ10 = mkobj.o    mkroom.o   mon.o	  mondata.o  monmove.o
VOBJ11 = monst.o    monstr.o   mplayer.o  mthrowu.o  muse.o
VOBJ12 = music.o    o_init.o   objects.o  objnam.o   options.o
VOBJ13 = pickup.o   pline.o    polyself.o potion.o   quest.o
VOBJ14 = questpgr.o pager.o    pray.o	  priest.o   read.o
VOBJ15 = rect.o	    restore.o  rip.o	  rnd.o	     role.o
VOBJ16 = rumors.o   save.o	   shk.o      shknam.o	 sit.o
VOBJ17 = sounds.o   sp_lev.o   spell.o    steal.o	 steed.o
VOBJ18 = termcap.o  timeout.o  topl.o	  topten.o   track.o
VOBJ19 = trap.o     u_init.o   uhitm.o    vault.o    vision.o
VOBJ20 = vis_tab.o  weapon.o   were.o	  wield.o    windows.o
VOBJ21 = wintty.o   wizard.o   worm.o	  worn.o     write.o
VOBJ22 = zap.o	    light.o    dlb.o      dig.o      teleport.o
VOBJ23 = region.o   tech.o     gypsy.o

SOBJ   = msdos.o    sound.o    sys.o	  tty.o	     unix.o    video.o \
	vidtxt.o    pckeys.o

VVOBJ  = version.o

VOBJ   = $(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) \
	$(VOBJ06) $(VOBJ07) $(VOBJ08) $(VOBJ09) $(VOBJ10) \
	$(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) $(VOBJ15) \
	$(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) \
	$(VOBJ21) $(VOBJ22) $(VOBJ23)

ALLOBJ = $(VOBJ) $(SOBJ) $(TILOBJ) $(VVOBJ)

#
#  Header Objects.
#

DGN_FILE_H = $(INCL)\align.h	$(INCL)\dgn_file.h
DUNGEON_H  = $(INCL)\align.h	$(INCL)\dungeon.h
EMIN_H	   = $(DUNGEON_H)	$(INCL)\emin.h
EPRI_H	   = $(DUNGEON_H)	$(INCL)\align.h	    $(INCL)\epri.h
ESHK_H	   = $(DUNGEON_H)	$(INCL)\eshk.h
MONDATA_H  = $(INCL)\align.h	$(INCL)\mondata.h
MONST_H	   = $(INCL)\align.h	$(INCL)\monst.h
PERMONST_H = $(INCL)\monattk.h	$(INCL)\monflag.h   $(INCL)\align.h   \
	    $(INCL)\permonst.h
REGION_H   = $(INCL)\region.h
RM_H	   = $(INCL)\align.h	$(INCL)\rm.h
SKILLS_H   = $(INCL)\skills.h
SP_LEV_H   = $(INCL)\align.h	$(INCL)\sp_lev.h
VAULT_H	   = $(DUNGEON_H)	$(INCL)\vault.h
YOUPROP_H  = $(PERMONST_H)	$(MONDATA_H)	    $(INCL)\prop.h    \
	    $(INCL)\pm.h       $(INCL)\youprop.h
YOU_H	   = $(MONST_H)		$(YOUPROP_H)	    $(INCL)\align.h   \
	     $(INCL)\attrib.h	$(INCL)\you.h
DISPLAY_H  = $(MONDATA_H)	$(INCL)\vision.h    $(INCL)\display.h
PCCONF_H   = $(INCL)\micro.h	$(INCL)\system.h    $(INCL)\pcconf.h \
	    $(INCL)\pcvideo.h
CONFIG_H   = $(GLOBAL_H)	$(INCL)\tradstdc.h  $(INCL)\config1.h \
	    $(INCL)\config.h
DECL_H	   = $(YOU_H)		$(INCL)\spell.h	    $(INCL)\color.h   \
	     $(INCL)\obj.h	$(INCL)\onames.h    $(INCL)\pm.h      \
	      $(INCL)\decl.h
GLOBAL_H   = $(PCCONF_H)	$(INCL)\coord.h	    $(INCL)\global.h
HACK_H	   = $(CONFIG_H)	$(DUNGEON_H)	    $(DECL_H)	      \
	       $(DISPLAY_H)	  $(INCL)\monsym.h    $(INCL)\mkroom.h	\
	      $(INCL)\objclass.h $(INCL)\trap.h	     $(INCL)\flag.h    \
	      $(RM_H)		 $(INCL)\vision.h    $(INCL)\wintype.h \
	      $(INCL)\engrave.h	 $(INCL)\rect.h	  \
	       $(INCL)\trampoli.h $(INCL)\hack.h $(REGION_H)
DLB_H      = $(INCL)\dlb.h

ifeq ($(SUPPRESS_GRAPHICS),Y)
TILE_H     =
else
TILE_H	   = $(INCL)\tile.h $(INCL)\pctiles.h
endif

ifeq ($(USE_DLB),Y)
DLB = dlb
DLBOBJS = dlb_main.o dlb.o alloc.o panic.o
else
DLB =
DLBOBJS =
endif

ifdef DJGPP
DJ1 = $(dir $(DJGPP))
CWSDPMI = $(subst /,\,$(DJ1))bin\CWSDPMI.*
endif

#
#  Make Rules.
#

.SUFFIXES:  .exe .o .c .y .l

C = $(CC) $(CFLAGS) -o$@ $<

.c.o:
	$C

#.phony: dlb

#
#  Primary Targets.
#

#  The default target.

default: $(GAMEFILE)

all: install.tag

util: utility.tag

install: install.tag

utility.tag: $(INCL)\date.h $(INCL)\trap.h    $(INCL)\onames.h	       \
	$(INCL)\pm.h	  monstr.c   vis_tab.c	$(INCL)\filename.h \
	lev_comp.exe	 dgn_comp.exe	 recover.exe $(TILEUTIL)
	echo utilities made > utility.tag

tileutil: gif2txt.exe txt2ppm.exe
	@echo Optional tile development utilities are up to date.

gamedir.tag:
	if not exist $(GAMEDIR)\NUL md $(GAMEDIR)
	echo $(GAMEDIR)\ made > gamedir.tag

install.tag: dat.tag gamedir.tag $(GAMEFILE)
ifeq ($(USE_DLB),Y)
	$(UPD) $(DAT)\nhshare       $(GAMEDIR)\nhshare
	$(UPD) $(DAT)\nhushare     $(GAMEDIR)\nhushare
	$(UPD) $(DAT)\license       $(GAMEDIR)\license
else
	copy $(DAT)\*.            $(GAMEDIR)
	copy $(DAT)\*.dat         $(GAMEDIR)
	copy $(DAT)\*.lev         $(GAMEDIR)
	$(UPD) $(MSYS)\msdoshlp.txt $(GAMEDIR)\msdoshlp.txt
	if exist $(GAMEDIR)\makefile. del $(GAMEDIR)\makefile.
endif
ifdef TERMLIB
	$(UPD) $(SSHR)\termcap	  $(GAMEDIR)\termcap
endif
	if exist *.tib copy *.tib                $(GAMEDIR)
	$(UPD) $(SSHR)\NetHack.cnf  $(GAMEDIR)\defaults.nh
	$(UPD) $(MSYS)\NHAccess.nh  $(GAMEDIR)\NHAccess.nh
#	copy $(SSHR)\NetHack.cnf  $(GAMEDIR)\$(GAME).cnf
ifeq ($(USE_ALLEGRO),Y)
	$(UPD) $(MSYS)\alleg.cnf  $(GAMEDIR)\alleg.cnf
	$(UPD) $(MSYS)\anethack.fnt $(GAMEDIR)\anethack.fnt
	if not exist $(GAMEDIR)\tiles\NUL md $(GAMEDIR)\tiles
ifeq ($(USE_BIG_BMP),Y)
	copy slam??.bmp $(GAMEDIR)
else
	$(UPD) index $(GAMEDIR)\tiles\index
	copy *.bmp $(GAMEDIR)\tiles
endif
	if not exist $(GAMEDIR)\tiles\spfx\NUL md $(GAMEDIR)\tiles\spfx
	if not exist $(GAMEDIR)\tiles\subs\NUL md $(GAMEDIR)\tiles\subs
	copy $(MSYS)\tiles\*.* $(GAMEDIR)\tiles
	copy $(MSYS)\tiles\spfx\*.* $(GAMEDIR)\tiles\spfx
	copy $(MSYS)\tiles\subs\*.* $(GAMEDIR)\tiles\subs
endif
	$(UPD) recover.exe          $(GAMEDIR)\recover.exe
	copy $(DOC)\guidebo*.txt   $(GAMEDIR)
	if exist $(DOC)\recover.txt \
		$(UPD) $(DOC)\recover.txt $(GAMEDIR)\recover.txt
	if exist $(DOC)\$(GAME).txt \
		$(UPD) $(DOC)\$(GAME).txt $(GAMEDIR)\$(GAME).txt
	if exist ..\readme.txt $(UPD) ..\readme.txt $(GAMEDIR)\readme.txt
	if exist ..\slamfaq.txt $(UPD) ..\slamfaq.txt $(GAMEDIR)\slamfaq.txt
	if exist ..\history.txt $(UPD) ..\history.txt $(GAMEDIR)\history.txt
ifdef CWSDPMI
	if exist $(CWSDPMI) copy $(CWSDPMI) $(GAMEDIR)
else
	echo Could not find a copy of CWSDPMI.EXE to put into $(GAMEDIR)
endif
	echo install done > install.tag

#  The main target.


$(GAMEFILE): utility.tag gamedir.tag $(GAME).lnk
	$(LINK) $(LFLAGS) -o$(GAME).exe @$(GAME).lnk $(LIBRARIES)
	stubedit $(GAME).exe minstack=2048K argv0=$(GAME)
ifdef EXECOMPRESS 
		$(EXECOMPRESS) $(GAME).exe
endif
	$(UPD) $(GAME).exe $(GAMEFILE)
	del $(GAME).exe

$(GAME).lnk: $(ALLOBJ)
	@echo $(VOBJ01) > $@
	@echo $(VOBJ02) >> $@
	@echo $(VOBJ03) >> $@
	@echo $(VOBJ04) >> $@
	@echo $(VOBJ05) >> $@
	@echo $(VOBJ06) >> $@
	@echo $(VOBJ07) >> $@
	@echo $(VOBJ08) >> $@
	@echo $(VOBJ09) >> $@
	@echo $(VOBJ10) >> $@
	@echo $(VOBJ11) >> $@
	@echo $(VOBJ12) >> $@
	@echo $(VOBJ13) >> $@
	@echo $(VOBJ14) >> $@
	@echo $(VOBJ15) >> $@
	@echo $(VOBJ16) >> $@
	@echo $(VOBJ17) >> $@
	@echo $(VOBJ18) >> $@
	@echo $(VOBJ19) >> $@
	@echo $(VOBJ20) >> $@
	@echo $(VOBJ21) >> $@
	@echo $(VOBJ22) >> $@
	@echo $(VOBJ23) >> $@
	@echo $(SOBJ)   >> $@
	@echo $(TILOBJ) >> $@
	@echo $(VVOBJ)  >> $@


#
#  Housekeeping.
#

clean:
	del *.o
	del *.map
	del dlb_main.exe

# JRN: cleaned out 'clean' and 'spotless'
spotless: clean
	del *.exe
	del *.tag
	if exist $(GAME).lnk	   del $(GAME).lnk
# yacc/bison, $(LEX), $(UPD): parsers for dungeon/level compiler
	if exist $(SRC)\lev_$(LEX).c  del $(SRC)\lev_$(LEX).c
	if exist $(SRC)\lev_yacc.c del $(SRC)\lev_yacc.c
	if exist $(INCL)\lev_comp.h del $(INCL)\lev_comp.h
	if exist $(SRC)\dgn_$(LEX).c  del $(SRC)\dgn_$(LEX).c
	if exist $(SRC)\dgn_yacc.c del $(SRC)\dgn_yacc.c
	if exist $(INCL)\dgn_comp.h del $(INCL)\dgn_comp.h
# makedefs: makedefs-generated source and headers
	if exist $(INCL)\date.h	   del $(INCL)\date.h
	if exist $(INCL)\onames.h  del $(INCL)\onames.h
	if exist $(INCL)\pm.h	   del $(INCL)\pm.h
	if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
	if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
	if exist $(INCL)\filename.h del $(INCL)\filename.h
# makedefs: makedefs-generated datafiles
	if exist $(DAT)\options	   del $(DAT)\options
	if exist $(DAT)\data	   del $(DAT)\data
	if exist $(DAT)\rumors	   del $(DAT)\rumors
	if exist $(DAT)\quest.dat  del $(DAT)\quest.dat
	if exist $(DAT)\oracles	   del $(DAT)\oracles
	if exist $(DAT)\dungeon.pdf del $(DAT)\dungeon.pdf
# $(UPD): headers for tile support
	if exist $(INCL)\tile.h	   del $(INCL)\tile.h
	if exist $(INCL)\pctiles.h del $(INCL)\pctiles.h
	if exist $(INCL)\pcvideo.h del $(INCL)\pcvideo.h
	if exist $(INCL)\portio.h  del $(INCL)\portio.h
# $(UPD): copied to dat for convenience
	if exist $(DAT)\lev_comp.exe del $(DAT)\lev_comp.exe
	if exist $(DAT)\msdoshlp.txt del $(DAT)\msdoshlp.txt
	if exist $(DAT)\dlb_main.exe del $(DAT)\dlb_main.exe
# $(UPD): copied to src out of necessity
#	[left intentionally blank]
# $(CC), $(LINK): evil messy compilers' trash
	if exist *.def		   del *.def
	if exist a.out		   del a.out
# txt2bmp: bitmap tiles
	if exist index             del index
	if exist $(INCL)\allegfx.h del $(INCL)\allegfx.h
	if exist *.bmp             del *.bmp
# lev_comp, dgn_comp: level and dungeon compiler compiled data
	if exist $(DAT)\*.lev      del $(DAT)\*.lev
	if exist $(DAT)\dungeon	   del $(DAT)\dungeon
# dlb_main: data library stuff
	if exist $(DAT)\nhshare    del $(DAT)\nhshare
	if exist $(DAT)\nhushare  del $(DAT)\nhushare
	if exist $(DAT)\dlb.lst    del $(DAT)\dlb.lst
	if exist $(DAT)\dlb2.lst    del $(DAT)\dlb2.lst
# tile2bin: datafiles for the standard VGA mode
	if exist *.tib		   del *.tib
	if exist $(DAT)\*.tib	   del $(DAT)\*.tib
# thintile: thin (overview) tiles
	if exist $(WSHR)\monthin.txt del $(WSHR)\monthin.txt
	if exist $(WSHR)\objthin.txt del $(WSHR)\objthin.txt
	if exist $(WSHR)\oththin.txt del $(WSHR)\oththin.txt
# txtmerge: merged (transparent) 32x32 tile files
	if exist $(WSHR)\mon32-t.txt del $(WSHR)\mon32-t.txt
	if exist $(WSHR)\obj32-t.txt del $(WSHR)\obj32-t.txt
	if exist $(WSHR)\oth32-t.txt del $(WSHR)\oth32-t.txt
# txtbg: 32x32 tile files with backgrounds
	if exist $(WSHR)\mon32.txt del $(WSHR)\mon32.txt
	if exist $(WSHR)\obj32.txt del $(WSHR)\obj32.txt
	if exist $(WSHR)\oth32.txt del $(WSHR)\oth32.txt
# magtile: magnified tile files (16x16 tiles -> 32x32 tiles)
	if exist $(WSHR)\monmag.txt del $(WSHR)\monmag.txt
	if exist $(WSHR)\objmag.txt del $(WSHR)\objmag.txt
	if exist $(WSHR)\othmag.txt del $(WSHR)\othmag.txt
# bigtile: recentered tile files (32x32 tiles -> 48x64 tiles)
	if exist $(WSHR)\monbig.txt del $(WSHR)\monbig.txt
	if exist $(WSHR)\objbig.txt del $(WSHR)\objbig.txt
	if exist $(WSHR)\othbig.txt del $(WSHR)\othbig.txt
# txtmerge: merged 3d (48x64) tile files
	if exist $(WSHR)\mon3d.txt del $(WSHR)\mon3d.txt
	if exist $(WSHR)\obj3d.txt del $(WSHR)\obj3d.txt
	if exist $(WSHR)\oth3d.txt del $(WSHR)\oth3d.txt
# redir/gcc: C warnings captured from -Wall -W if you're me
	if exist cerrors.out	   del cerrors.out
# tilemap: tile.c ??
	if exist tile.c		   del tile.c
	@echo All clean, hopefully!  If you get any cruft, e-mail WACko or me

#
#  Secondary Targets.
#
#  The following include files depend on makedefs to be created.
#
#  date.h should be remade every time any of the source or include
#  files is modified.

# For the Makefile surfer
#	(or strange person who goes 'make ../dat/options'):
$(DAT)\options : $(INCL)\date.h

$(INCL)\date.h : makedefs.exe
	-makedefs -v

$(INCL)\onames.h: makedefs.exe
	-makedefs -o

$(INCL)\pm.h: makedefs.exe
	-makedefs -p

monstr.c: makedefs.exe
	-makedefs -m

$(INCL)\vis_tab.h: makedefs.exe
	-makedefs -z

vis_tab.c: makedefs.exe
	-makedefs -z

$(INCL)\filename.h: makedefs.exe
	-makedefs -f

#
#  Makedefs Stuff
#

makedefs.exe:  $(MAKEOBJS)
	$(LINK) $(LFLAGS) -omakedefs.exe $(MAKEOBJS)

makedefs.o:  $(UTIL)\makedefs.c $(CONFIG_H)	$(PERMONST_H) \
	$(INCL)\objclass.h $(INCL)\monsym.h   $(INCL)\qtext.h 
	$C

#
#  Level Compiler Dependencies
#

lev_comp.exe:  $(SPLEVOBJS)
	$(LINK) $(LFLAGS) -olev_comp.exe $(SPLEVOBJS)

lev_yacc.o:	$(HACK_H) $(SP_LEV_H) $(INCL)\lev_comp.h 
lev_$(LEX).o:	$(HACK_H) $(SP_LEV_H) $(INCL)\lev_comp.h	
lev_main.o:  $(UTIL)\lev_main.c $(HACK_H)
	$C

$(INCL)\lev_comp.h: lev_yacc.c

ifeq ($(YACC_LEX),Y)
lev_yacc.c:  $(UTIL)\lev_comp.y
	$(YACC) -d $(DUTIL)/lev_comp.y
	$(UPD) $(YTABC) $@
	$(UPD) $(YTABH) $(INCL)\lev_comp.h
	del $(YTABC)
	del $(YTABH)
$(INCL)\lev_comp.h: lev_yacc.c
lev_$(LEX).c:  $(UTIL)\lev_comp.l
	$(LEX) $(DUTIL)/lev_comp.l 
	$(UPD) $(LEXYYC) $@
	del $(LEXYYC)
else
lev_yacc.c: $(SSHR)\lev_yacc.c
	$(UPD) $(SSHR)\lev_yacc.c $@
$(INCL)\lev_comp.h: $(SSHR)\lev_comp.h
	$(UPD) $(SSHR)\lev_comp.h $@
	touch $(DINCL)/lev_comp.h
lev_$(LEX).c: $(SSHR)\lev_lex.c
	$(UPD) $(SSHR)\lev_lex.c $@
endif

#
#  Dungeon Dependencies
#

dgn_comp.exe:  $(DGNCOMPOBJS)
	$(LINK) $(LFLAGS) -odgn_comp.exe $(DGNCOMPOBJS)
dgn_yacc.o:	$(HACK_H) $(DGN_FILE_H)	$(INCL)\dgn_comp.h 
dgn_$(LEX).o:	$(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h
dgn_main.o:	$(UTIL)\dgn_main.c $(HACK_H)
	$C

ifeq ($(YACC_LEX),Y)
dgn_yacc.c: $(UTIL)\dgn_comp.y
	$(YACC) -d $(DUTIL)/dgn_comp.y
	$(UPD) $(YTABC) $@
	$(UPD) $(YTABH) $(INCL)\dgn_comp.h
	del $(YTABC)
	del $(YTABH)
$(INCL)\dgn_comp.h: dgn_yacc.c
dgn_$(LEX).c:  $(UTIL)\dgn_comp.l
	$(LEX) $(DUTIL)/dgn_comp.l
	$(UPD) $(LEXYYC) $@
	del $(LEXYYC)
else
dgn_yacc.c: $(SSHR)\dgn_yacc.c
	$(UPD) $(SSHR)\dgn_yacc.c $@

$(INCL)\dgn_comp.h: $(SSHR)\dgn_comp.h
	$(UPD) $(SSHR)\dgn_comp.h $@
	touch $(DINCL)/dgn_comp.h

dgn_$(LEX).c: $(SSHR)\dgn_lex.c
	$(UPD) $(SSHR)\dgn_lex.c $@
endif

#
#  Recover Utility
#

recover.exe:   $(RECOVOBJS)
	$(LINK) $(LFLAGS) -orecover.exe recover.o
ifdef EXECOMPRESS
	$(EXECOMPRESS) recover.exe
endif

recover.o:   $(UTIL)\recover.c $(CONFIG_H)
	$C

#
#  Header file moves required for tile support
#
ifeq ($(SUPPRESS_GRAPHICS),Y)

else

$(INCL)\tile.h: $(WSHR)\tile.h
	$(UPD) $< $@

$(INCL)\pctiles.h: $(MSYS)\pctiles.h
	$(UPD) $< $@

$(INCL)\pcvideo.h: $(MSYS)\pcvideo.h
	$(UPD) $< $@

$(INCL)\portio.h: $(MSYS)\portio.h
	$(UPD) $< $@

#
#  Tile Mapping
#

tile.c: tilemap.exe
	tilemap.exe
	@echo A new $@ has been created

tilemap.exe: tilemap.o
	$(LINK) $(LFLAGS) -otilemap.exe tilemap.o

tilemap.o: $(WSHR)\tilemap.c $(HACK_H) $(TILE_H)
	$C
#
#   Tile Utilities
#
#
#  Required for tile support
#

$(GAME)1.tib: $(TILEFILES) tile2bin.exe
	@echo Creating binary tile files (this may take some time)
	@tile2bin

$(GAME)o.tib: thintile.tag $(TILEFILES2) til2bin2.exe
	@echo Creating overview binary tile files (this may take some time)
	@til2bin2

tile2bin.exe: tile2bin.o $(TEXTIO)
	$(LINK) $(LFLAGS) -otile2bin.exe tile2bin.o $(TEXTIO)

til2bin2.exe: til2bin2.o $(TEXTIO)
	$(LINK) $(LFLAGS) -otil2bin2.exe til2bin2.o $(TEXTIO)

thintile.exe: thintile.o $(TEXTIO)
	$(LINK) $(LFLAGS) -othintile.exe thintile.o $(TEXTIO)

thintile.o: $(WSHR)\thintile.c $(HACK_H) $(INCL)\tile.h
	$C

# thintiles = $(TILEFILES2)
thintile.tag: thintile.exe $(TILEFILES)
	thintile
	@echo thintiles created >thintile.tag

tile2bin.o: $(MSYS)\tile2bin.c $(HACK_H) $(INCL)\tile.h $(INCL)\pctiles.h \
	$(INCL)\pcvideo.h
	$C

til2bin2.o:  $(HACK_H) $(INCL)\tile.h $(INCL)\pctiles.h $(INCL)\pcvideo.h \
	$(MSYS)\tile2bin.c
	$(CC) $(CFLAGS) -DTILE_X=8 -DOVERVIEW_FILE -o$@ $(MSYS)\tile2bin.c

tiletext.o:  $(WSHR)\tiletext.c $(CONFIG_H) $(INCL)\tile.h
	$C

tiletex2.o:  $(WSHR)\tiletext.c $(CONFIG_H) $(INCL)\tile.h
	$(CC) $(CFLAGS) -DTILE_X=8 -o$@ $<
  
tiletxt.o:  $(WSHR)\tilemap.c $(CONFIG_H) $(INCL)\tile.h
	$(CC) $(CFLAGS) -DTILETEXT -o$@ $<
  
tiletxt2.o: $(WSHR)\tilemap.c $(CONFIG_H) $(INCL)\tile.h
	$(CC) $(CFLAGS) -DTILETEXT -DTILE_X=8 -o$@ $<

#
# Allegro Tile Support
#

txt2bmp.o:  $(MSYS)\txt2bmp.c $(HACK_H) $(INCL)\tile.h $(INCL)\portio.h
	$C

txt2bmp.exe: txt2bmp.o $(TEXTIO) tile.c
	$(LINK) $(LFLAGS) -o$@ $< -lalleg $(TEXTIO)

idx2bmp.o:  $(MSYS)\idx2bmp.c $(HACK_H) $(INCL)\tile.h $(INCL)\portio.h
	$C

idx2bmp.exe: idx2bmp.o $(TEXTIO)
	$(LINK) $(LFLAGS) -o$@ $< -lalleg $(TEXTIO)

bmp2txt.o:  $(MSYS)\bmp2txt.c $(HACK_H) $(INCL)\tile.h $(INCL)\portio.h
	$C

bmp2txt.exe: bmp2txt.o $(TEXTIO)
	$(LINK) $(LFLAGS) -obmp2txt.exe bmp2txt.o -lalleg $(TEXTIO)

allegro.tag: txt2bmp.exe alltiles.tag
	echo allegro tiles made > allegro.tag

index: txt2bmp.exe
	txt2bmp.exe -i

#
# 32x32 Tile Support
#

txtbg.exe: txtbg.o $(TEXTIO)
	$(LINK) $(LFLAGS) -otxtbg.exe txtbg.o $(TEXTIO)

txtbg.o: $(WSHR)\txtbg.c $(INCL)\hack.h $(INCL)\tile.h
	$C

txtmerge.exe: txtmerge.o $(TEXTIO)
	$(LINK) $(LFLAGS) -otxtmerge.exe txtmerge.o $(TEXTIO)

magtile.exe: magtile.o $(TEXTIO)
	$(LINK) $(LFLAGS) -omagtile.exe magtile.o $(TEXTIO)

magtile.o: $(WSHR)\magtile.c $(INCL)\config.h $(INCL)\tile.h
	$C

bigtile.exe: bigtile.o $(TEXTIO)
	$(LINK) $(LFLAGS) -obigtile.exe bigtile.o $(TEXTIO)

bigtile.o: $(WSHR)\bigtile.c $(INCL)\config.h $(INCL)\tile.h
	$C

txtmerge.o: $(WSHR)\txtmerge.c $(INCL)\config.h $(INCL)\tile.h
	$C

$(WSHR)\monmag.txt:	magtile.exe $(WSHR)\monsters.txt
	magtile

$(WSHR)\objmag.txt:	magtile.exe $(WSHR)\objects.txt
	magtile

$(WSHR)\othmag.txt:	magtile.exe $(WSHR)\other.txt
	magtile

$(WSHR)\mon32-t.txt:	txtmerge.exe $(WSHR)\monmag.txt $(WSHR)\mon32mi.txt \
			$(WSHR)\mon32alg.txt $(WSHR)\mon32al2.txt \
			$(WSHR)\mon32aw.txt
	txtmerge $(WSHR)\mon32-t.txt $(WSHR)\monmag.txt -b $(WSHR)\mon32mi.txt \
		-bff00ff $(WSHR)\mon32alg.txt \
		-bff00ff $(WSHR)\mon32al2.txt \
		-bff00ff $(WSHR)\mon32aw.txt
			

$(WSHR)\obj32-t.txt:	txtmerge.exe $(WSHR)\objmag.txt $(WSHR)\obj32mi.txt \
			$(WSHR)\obj32se.txt $(WSHR)\obj32alg.txt \
			$(WSHR)\obj32al2.txt
	txtmerge $(WSHR)\obj32-t.txt $(WSHR)\objmag.txt \
		-b $(WSHR)\obj32mi.txt -b $(WSHR)\obj32se.txt \
		-bff00ff $(WSHR)\obj32alg.txt \
		-bff00ff $(WSHR)\obj32al2.txt

$(WSHR)\oth32-t.txt:	txtmerge.exe $(WSHR)\othmag.txt \
		$(WSHR)\oth32mi.txt $(WSHR)\oth32se.txt \
		$(WSHR)\oth32fl.txt \
		-bff00ff $(WSHR)\oth32alg.txt \
		-bff00ff $(WSHR)\oth32al2.txt
	cd $(WSHR)
	..\$(SRC)\txtmerge oth32-t.txt othmag.txt \
		-b oth32mi.txt oth32se.txt \
		oth32fl.txt -bff00ff oth32alg.txt \
		-bff00ff oth32al2.txt
	cd ..\$(SRC)

$(WSHR)\mon32.txt:	txtbg.exe $(WSHR)\mon32-t.txt
	txtbg $(WSHR)\mon32-t.txt $(WSHR)\mon32.txt

$(WSHR)\obj32.txt:	txtbg.exe $(WSHR)\obj32-t.txt
	txtbg $(WSHR)\obj32-t.txt $(WSHR)\obj32.txt

$(WSHR)\oth32.txt:	txtbg.exe $(WSHR)\oth32-t.txt
	txtbg $(WSHR)\oth32-t.txt $(WSHR)\oth32.txt

$(WSHR)\monbig.txt:	bigtile.exe $(WSHR)\mon32-t.txt
	bigtile

$(WSHR)\objbig.txt:	bigtile.exe $(WSHR)\obj32-t.txt
	bigtile

$(WSHR)\othbig.txt:	bigtile.exe $(WSHR)\oth32-t.txt
	bigtile

$(WSHR)\mon3d.txt:	txtmerge.exe $(WSHR)\monbig.txt $(WSHR)\mon3dmi.txt
	txtmerge ../win/share/mon3d.txt ../win/share/monbig.txt \
		../win/share/mon3dmi.txt 

$(WSHR)\obj3d.txt:	txtmerge.exe $(WSHR)\objbig.txt
	txtmerge ../win/share/obj3d.txt ../win/share/objbig.txt

$(WSHR)\oth3d.txt:	txtmerge.exe $(WSHR)\othbig.txt \
			../win/share/oth3dmi.txt ../win/share/oth-2kmi.txt
	txtmerge ../win/share/oth3d.txt ../win/share/othbig.txt \
		../win/share/oth3dmi.txt ../win/share/oth-2kmi.txt

# For makefile greppers that want to know what the heck allegfx.h is
$(INCL)\allegfx.h: txt2bmp.exe
	txt2bmp.exe -h
	echo You just made something completely useless!!  Congrats!

tiles3d.tag:	$(WSHR)\mon3d.txt $(WSHR)\obj3d.txt $(WSHR)\oth3d.txt txt2bmp.exe
	txt2bmp.exe $(txt2bmp_FLG)3d
	echo tiles3d done > tiles3d.tag

tiles32.tag:	$(WSHR)\mon32.txt $(WSHR)\obj32.txt $(WSHR)\oth32.txt txt2bmp.exe
	txt2bmp.exe $(txt2bmp_FLG)32
	echo tiles32 done > tiles32.tag

tiles16.tag:	$(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt txt2bmp.exe
	txt2bmp.exe $(txt2bmp_FLG)16
	echo tiles16 done > tiles16.tag

alltiles.tag:  tiles32.tag tiles16.tag tiles3d.tag
	echo alltiles done > alltiles.tag

#
# Optional GIF Utilities (for development)
#

gif2txt.exe: $(GIFREADERS) $(TEXTIO)
	$(LINK) $(LFLAGS) -ogif2txt.exe $(GIFREADERS) $(TEXTIO)

igif2txt.exe: $(IGIFREADERS) $(TEXTIO)
	$(LINK) $(LFLAGS) -oigif2txt.exe $(IGIFREADERS) $(TEXTIO)

txt2ppm.exe: $(PPMWRITERS) $(TEXTIO)
	$(LINK) $(LFLAGS) -otxt2ppm.exe $(PPMWRITERS) $(TEXTIO)

txtfilt.exe: txtfilt.o $(TEXT_IO)
	$(CC) $(LFLAGS) -otxtfilt.exe txtfilt.o $(TEXTIO)

gifread.o: $(WSHR)\gifread.c $(CONFIG_H) $(INCL)\tile.h
	$C
igifread.o: $(WSHR)\gifread.c $(CONFIG_H) $(INCL)\tile.h
	$(CC) $(CFLAGS) -DINDEX -o$@ $<
ppmwrite.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(INCL)\tile.h
	$C
txtfilt.o: $(WSHR)\txtfilt.c $(INCL)\config.h $(INCL)\tile.h
	$C

#
#  Optional tile viewer (development sources only)
#

viewtib.exe: viewtib.o
	$(LINK) $(LFLAGS) -oviewtib.exe viewtib.o $(LIBRARIES)

viewtib.o: $(MSYS)\viewtib.c
	$C

endif

#
#  Other Util Dependencies.
#
#JRN huh? removed the the whole thing.  It's weird.  Aren't its
# dependencies at the end with the other "normal" things? And whenever
# monst.o is made, so is objects.o, so why depend?

panic.o: $(UTIL)\panic.c  $(CONFIG_H)
	$C



#
# make data.base an 8.3 filename to prevent an nmake warning
#

DATABASE = $(DAT)\data.bas


dat.tag: $(DAT)\nhshare $(DAT)\nhushare
	@echo dat done >dat.tag

$(DAT)\data:	 utility.tag	$(DATABASE)
	makedefs -d

$(DAT)\rumors:	     utility.tag    $(DAT)\rumors.tru	$(DAT)\rumors.fal
	makedefs -r

$(DAT)\quest.dat: utility.tag  $(DAT)\quest.txt
	makedefs -q

$(DAT)\oracles:	     utility.tag    $(DAT)\oracles.txt
	makedefs -h

$(DAT)\dungeon.pdf: utility.tag $(DAT)\dungeon.def
	makedefs -e

sp_lev.tag: lev_comp.exe     $(DAT)\beholder.des $(DAT)\bigroom.des \
	$(DAT)\blkmar.des   $(DAT)\castle.des   $(DAT)\caves.des \
	$(DAT)\dragons.des  $(DAT)\endgame.des \
	$(DAT)\gehennom.des $(DAT)\giants.des   $(DAT)\guild.des \
	$(DAT)\knox.des     $(DAT)\kobold-1.des $(DAT)\kobold-2.des \
	$(DAT)\lich.des     $(DAT)\mall-1.des   $(DAT)\mall-2.des \
	$(DAT)\medusa.des   $(DAT)\sokoban.des \
	$(DAT)\mines.des    $(DAT)\mtemple.des  $(DAT)\newmall.des \
	$(DAT)\nymph.des    $(DAT)\oracle.des   $(DAT)\rats.des \
	$(DAT)\sea.des      $(DAT)\spiders.des  $(DAT)\stor-1.des \
	$(DAT)\stor-2.des   $(DAT)\stor-3.des   $(DAT)\tomb.des \
	$(DAT)\tower.des    $(DAT)\yendor.des \
	$(DAT)\arch.des     $(DAT)\barb.des 	$(DAT)\caveman.des \
	$(DAT)\flame.des \
	$(DAT)\healer.des 	$(DAT)\ice.des \
	$(DAT)\knight.des   $(DAT)\monk.des \
	$(DAT)\necro.des    $(DAT)\priest.des   $(DAT)\rogue.des \
	$(DAT)\samurai.des  $(DAT)\tourist.des  $(DAT)\slayer.des \
	$(DAT)\valkyrie.des $(DAT)\wizard.des   $(DAT)\yeoman.des \
	$(DAT)\frnknstn.des $(DAT)\nightmar.des $(DAT)\ranger.des 

	$(UPD) $(SRC)\lev_comp.exe $(DAT)\lev_comp.exe
	cd $(DAT)
	lev_comp beholder.des
	lev_comp bigroom.des
	lev_comp blkmar.des
	lev_comp castle.des
	lev_comp caves.des
#	lev_comp darkelf.des
	lev_comp dragons.des
	lev_comp endgame.des
	lev_comp gehennom.des
	lev_comp giants.des
	lev_comp guild.des
	lev_comp knox.des
	lev_comp kobold-1.des
	lev_comp kobold-2.des
	lev_comp lich.des
	lev_comp mall-1.des
	lev_comp mall-2.des
	lev_comp medusa.des
	lev_comp sokoban.des
	lev_comp mines.des
	lev_comp mtemple.des
	lev_comp newmall.des
	lev_comp nymph.des
	lev_comp oracle.des
	lev_comp rats.des
	lev_comp sea.des
	lev_comp spiders.des
	lev_comp stor-1.des
	lev_comp stor-2.des
	lev_comp stor-3.des
	lev_comp tomb.des
	lev_comp tower.des
	lev_comp yendor.des
	lev_comp arch.des
	lev_comp barb.des
	lev_comp caveman.des
#	lev_comp dopp.des
#	lev_comp elf.des
	lev_comp flame.des
#	lev_comp gnome.des
	lev_comp healer.des
	lev_comp ice.des
	lev_comp knight.des
#	lev_comp lycn.des
	lev_comp monk.des
	lev_comp necro.des
	lev_comp priest.des
	lev_comp rogue.des
	lev_comp samurai.des
	lev_comp tourist.des
	lev_comp slayer.des
	lev_comp valkyrie.des
	lev_comp wizard.des
	lev_comp yeoman.des
#	lev_comp hobbit.des
	lev_comp frnknstn.des
#	lev_comp dwarf.des
	lev_comp nightmar.des
	lev_comp ranger.des
	cd $(SRC)
	echo sp_levs done > sp_lev.tag
	
$(DAT)\dungeon:	  utility.tag  $(DAT)\dungeon.pdf
	dgn_comp.exe $(DAT)\dungeon.pdf
#
# DLB stuff
#
#note that dir below assumes bin/dir.exe from djgpp distribution
#
	
$(DAT)\dlb.lst: 
	@echo data >$@
	@echo oracles >>$@
	@echo options >>$@
	@echo rumors >>$@
	@echo help >>$@
	@echo hh >>$@
	@echo cmdhelp >>$@
	@echo history >>$@
	@echo opthelp >>$@
	@echo wizhelp >>$@
	@echo license >>$@
	@echo msdoshlp.txt >>$@
	@echo gypsy.txt >>$@
	
$(DAT)\nhshare:	dlb_main.exe $(DAT)\data $(DAT)\rumors \
	    $(DAT)\oracles $(DAT)\dlb.lst
	@$(UPD) $(MSYS)\msdoshlp.txt $(DAT)\msdoshlp.txt
	dlb_main CcvIf $(DAT) dlb.lst nhshare
	@cd $(SRC)

$(DAT)\nhushare:	dlb_main.exe $(DAT)\dungeon $(DAT)\quest.dat sp_lev.tag
	@cd $(DAT)

	@echo dungeon >dlb2.lst
	@echo quest.dat >>dlb2.lst

	$(LS) *.lev >>dlb2.lst

#	@copy $(SRC)\*.tib .
#	$(LS) *.tib >>dlb2.lst

	dlb_main cvIf dlb2.lst nhushare
	@cd $(SRC)

dlb_main.exe: $(DLBOBJS)
	$(LINK) $(LFLAGS) -odlb_main.exe $(DLBOBJS)
	@$(UPD) $@ $(DAT)\dlb_main.exe


dlb_main.o: $(UTIL)\dlb_main.c $(INCL)\config.h $(DLB_H)
	$C
# Game Dependencies
# Some files require movement as Gnu make doesn't like unix style '/'
# directory specs and djgcc doesn't like dos style directory specs.
# So we get to copy stuff where we might need it.   Fun eh?
# Unfortunately, JRN spoiled the fun with his little $C thing.  Sorry =)

# sys/share
main.o:	$(SSHR)\pcmain.c $(HACK_H) $(DLB_H)
	$C
tty.o:	 $(SSHR)\pctty.c $(HACK_H) $(INCL)\wintty.h
	$C
unix.o:	 $(SSHR)\pcunix.c $(HACK_H)
	$C
sys.o : $(SSHR)\pcsys.c $(HACK_H)
	$C
# sys/msdos
msdos.o :  $(MSYS)\msdos.c $(HACK_H)
	$C
pckeys.o :  $(MSYS)\pckeys.c $(HACK_H)
	$C
pctiles.o :  $(MSYS)\pctiles.c $(HACK_H) $(INCL)\portio.h
	$C
sound.o :  $(MSYS)\sound.c $(HACK_H) $(INCL)\portio.h
	$C
video.o :  $(MSYS)\video.c $(HACK_H) $(INCL)\pcvideo.h $(INCL)\portio.h
	$C
# JRN: Instead of copying all those header files from $(MSYS), just use -I
vidalleg.o : $(MSYS)\vidalleg.c $(HACK_H)  $(INCL)\pcvideo.h $(INCL)\portio.h \
	$(TILE_H) $(MSYS)\alginit.h $(MSYS)\alfuncs.h $(MSYS)\alnames.h \
		$(MSYS)\loadfont.h $(MSYS)\2xsai.h
	$(CC) $(CFLAGS) -I$(MSYS) -o$@ $(AAFLAG) $<
2xsai.o: $(MSYS)\2xsai.c $(MSYS)\2xsai.h
	$(CC) $(CFLAGS) -I$(MSYS) $<
vidvga.o : $(MSYS)\vidvga.c $(HACK_H) $(INCL)\pcvideo.h $(INCL)\portio.h \
		$(TILE_H)
	$C
vidtxt.o : $(MSYS)\vidtxt.c $(HACK_H) $(INCL)\pcvideo.h $(INCL)\portio.h \
		$(TILE_H)
	$C
stubvid.o : $(MSYS)\video.c $(HACK_H)
	$(CC) $(CFLAGS) -DSTUBVIDEO -o$@ $<

# win/tty
getline.o : $(WIN)\getline.c $(HACK_H) $(INCL)\wintty.h
	$C
termcap.o : $(WIN)\termcap.c $(CONFIG_H)
	$C
topl.o : $(WIN)\topl.c $(CONFIG_H)
	$C
wintty.o : $(WIN)\wintty.c $(HACK_H)
	$C
# src dependencies
allmain.o:  $(HACK_H)
alloc.o:    $(CONFIG_H)
apply.o:    $(HACK_H) $(INCL)\edog.h
artifact.o: $(HACK_H) $(INCL)\artifact.h $(INCL)\artilist.h
attrib.o:   $(HACK_H) $(INCL)\artifact.h
ball.o:	    $(HACK_H)
bones.o:    $(HACK_H) $(INCL)\lev.h
borg.o:	    $(HACK_H) $(INCL)\func_tab.h
botl.o:	    $(HACK_H)
cmd.o:	    $(HACK_H) $(INCL)\func_tab.h
dbridge.o:  $(HACK_H)
decl.o:	    $(HACK_H) $(INCL)\quest.h
detect.o:   $(HACK_H) $(INCL)\artifact.h
dig.o:      $(HACK_H)
display.o:  $(HACK_H)
dlb.o:      $(HACK_H) $(DLB_H)
do.o:	    $(HACK_H) $(INCL)\lev.h
do_name.o:  $(HACK_H)
do_wear.o:  $(HACK_H)
dog.o:	    $(HACK_H) $(INCL)\edog.h
dogmove.o:  $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
dokick.o:   $(HACK_H) $(ESHK_H)
dothrow.o:  $(HACK_H)
drawing.o:  $(HACK_H) $(INCL)\tcap.h
dungeon.o:  $(HACK_H) $(INCL)\dgn_file.h
eat.o:	    $(HACK_H)
end.o:	    $(HACK_H) $(ESHK_H)
engrave.o:  $(HACK_H) $(INCL)\lev.h
exper.o:    $(HACK_H)
explode.o:  $(HACK_H)
extralev.o:  $(HACK_H)
files.o:     $(HACK_H) $(INCL)\file.h $(INCL)\filename.h
fountain.o:  $(HACK_H)
gypsy.o:     $(HACK_H) $(INCL)\egyp.h $(INCL)\qtext.h
hack.o:	     $(HACK_H)
hacklib.o:   $(HACK_H)
invent.o:    $(HACK_H) $(INCL)\artifact.h
light.o:     $(HACK_H) $(INCL)\lev.h
lock.o:	     $(HACK_H)
mail.o:	     $(HACK_H) $(INCL)\mail.h
makemon.o:   $(HACK_H) $(EPRI_H) $(EMIN_H) $(INCL)\edog.h
mcastu.o:    $(HACK_H)
mapglyph.o:  $(HACK_H)
mhitm.o:     $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
mhitu.o:     $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
minion.o:    $(HACK_H) $(EMIN_H) $(EPRI_H)
mklev.o:     $(HACK_H)
mkmap.o:     $(HACK_H) $(INCL)\sp_lev.h
mkmaze.o:    $(HACK_H) $(INCL)\sp_lev.h
mkobj.o:     $(HACK_H) $(INCL)\artifact.h $(INCL)\prop.h
mkroom.o:    $(HACK_H)
mon.o:	     $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
mondata.o:   $(HACK_H) $(ESHK_H) $(EPRI_H)
monmove.o:   $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
monst.o:     $(CONFIG_H) $(PERMONST_H) $(ESHK_H) $(EPRI_H) $(VAULT_H) \
	  $(INCL)\color.h $(INCL)\monsym.h
mplayer.o:   $(HACK_H)
mthrowu.o:   $(HACK_H)
muse.o:	     $(HACK_H)
music.o:     $(HACK_H)
o_init.o:    $(HACK_H)
objects.o:   $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h \
	       $(INCL)\prop.h $(SKILLS_H) $(INCL)\color.h
objnam.o:    $(HACK_H)
options.o:   $(CONFIG_H) $(HACK_H) $(INCL)\objclass.h $(INCL)\flag.h \
	      $(INCL)\tcap.h
pager.o:     $(HACK_H)
pickup.o:    $(HACK_H)
pline.o:     $(HACK_H) $(EPRI_H)
polyself.o:  $(HACK_H)
potion.o:    $(HACK_H)
pray.o:	     $(HACK_H) $(EPRI_H)
priest.o:    $(HACK_H) $(INCL)\mfndpos.h $(ESHK_H) $(EPRI_H) $(EMIN_H)
quest.o:     $(HACK_H) $(INCL)\quest.h $(INCL)\qtext.h
questpgr.o:  $(HACK_H) $(INCL)\qtext.h
read.o:	     $(HACK_H)
rect.o:	     $(HACK_H)
region.o:    $(HACK_H)
restore.o:   $(HACK_H) $(INCL)\lev.h $(INCL)\tcap.h $(INCL)\quest.h
rip.o:	     $(HACK_H)
role.o:	     $(HACK_H)
rnd.o:	     $(HACK_H)
rumors.o:    $(HACK_H)
save.o:	     $(HACK_H) $(INCL)\lev.h $(INCL)\quest.h
shk.o:	     $(HACK_H) $(ESHK_H)
shknam.o:    $(HACK_H) $(ESHK_H)
sit.o:	     $(HACK_H) $(INCL)\artifact.h
sounds.o:    $(HACK_H) $(INCL)\edog.h
sp_lev.o:    $(HACK_H) $(INCL)\sp_lev.h $(INCL)\align.h $(INCL)\rect.h
spell.o:     $(HACK_H)
steal.o:     $(HACK_H)
steed.o:     $(HACK_H)
tech.o:	     $(HACK_H) $(INCL)\tech.h
teleport.o:  $(HACK_H)
tile.o:	     $(HACK_H) $(TILE_H)
timeout.o:   $(HACK_H)
topten.o:    $(HACK_H)
track.o:     $(HACK_H)
trap.o:	     $(HACK_H)
u_init.o:    $(HACK_H)
uhitm.o:     $(HACK_H)
vault.o:     $(HACK_H) $(INCL)\vault.h
version.o:   $(HACK_H) $(INCL)\patchlev.h
vision.o:    $(HACK_H) $(INCL)\vis_tab.h
weapon.o:    $(HACK_H) $(INCL)\skills.h
were.o:	     $(HACK_H)
wield.o:     $(HACK_H)
windows.o:   $(HACK_H) $(INCL)\wintty.h
wizard.o:    $(HACK_H) $(INCL)\qtext.h
worm.o:	     $(HACK_H) $(INCL)\lev.h
worn.o:	     $(HACK_H)
write.o:     $(HACK_H)
zap.o:	     $(HACK_H)

# end of file
